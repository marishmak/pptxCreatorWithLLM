# -*- coding: utf-8 -*-
"""ATLLM_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18totp36aI5Zebn0VMEn6udsoOGUMztU-

# Imports
"""

from background import keep_alive
import pip
pip.main(['install', 'chromadb', 'google-generativeai', 'python-pptx', 'PyPDF2', 'pyTelegramBotAPI'])

import chromadb
from chromadb.utils import embedding_functions
from google.colab import userdata
import google.generativeai as genai
from sentence_transformers import SentenceTransformer
import csv
import json
import telebot
from telebot import types
import os
import getpass
import PyPDF2
import re
import time

"""# Presentation creation"""

def setup_database(embedding_function):
    db = chromadb.Client()
    collection = db.get_or_create_collection('course', embedding_function=embedding_function)
    return collection

# Create a custom embedding function class
class SentenceTransformerEmbeddingFunction(embedding_functions.EmbeddingFunction):
    def __init__(self, model):
        self.model = model

    def call(self, input):
        # Expecting input to be a list of dictionaries with a 'content' key
        return self.model.encode(input)

client = chromadb.Client()


# Use the embedding model from SentenceTransformers
embedder = SentenceTransformer('all-MiniLM-L6-v2')

# Initialize the custom embedding function
embedding_function = SentenceTransformerEmbeddingFunction(embedder)

genai.configure(api_key='AIzaSyDdNdaTlqA3IocMUq2CtBVQ4dlYLGx6eMs')
model = genai.GenerativeModel('gemini-1.5-flash')

def generate_content(prompt: str) -> str:

  try:
    response = model.generate_content(prompt)
    return response.text if hasattr(response, 'text') else "Sorry, I couldn't generate a response."
  except Exception as e:
    return f"There was an error generating the response: {str(e)}"

  return "Sorry, I couldn't generate a response."


def generate_prompt_for_db(text):
  prompt_input = f"""
You are an assistant with artificial intelligence who corrects this text, preprocess the text so that the connected words are separated by a space, turn it into a coherent text, and outputs convenient for use in creating a presentation.
Text:
{text}
Please provide output only in this format without anything else. If the text is not suitable for creating a presentation slide, print one word - 'Inconsistent'.
Format example:
Title:: Some title
Text:: Some text from given text
"""
  content = generate_content(prompt_input)

  return content

def database_replenishment(content, collection):

      content = content[8:].split('Title:: ')

      for i in content:
        i = i.split('Text:: ')
        if len(i)==2:
          title = i[0]
          text = i[1]

        # Add page as documents to the vector database
          collection.add(
              documents=[text],
              metadatas=[{"title": title}],
              ids=['ids'+str(collection.count())],
              embeddings=embedding_function.call(text)
            )


def extract_text_from_pdf(pdf_path, collection, message, msg):
  # removing special characters and tags from the documents
  pattern=r"[^\w]"

  with open(pdf_path, 'rb') as pdf_file:
    pdf_reader = PyPDF2.PdfReader(pdf_file)

    for i, page in enumerate(pdf_reader.pages):

      text = page.extract_text()

      if i%10==0:
        bot.edit_message_text(chat_id = message.chat.id, message_id = msg.message_id, text = f"Please wait while the file is being written to the database. It may take some time.\nDone...{round(i/len(pdf_reader.pages)*100, 2)}%")

      if text:

        text=re.sub(pattern, " ", text)

        content = generate_prompt_for_db(text)
        print(content)


        if 'Inconsistent' not in content and 'There was an error generating the response:' not in content and "Sorry, I couldn't generate a response."  not in content:
          database_replenishment(content, collection)

  print('Successful')

# Commented out IPython magic to ensure Python compatibility.
def generate_quastion_for_PP_code(topics, text, name):
  prompt_input = f"""
You are an assistant with artificial intelligence who generates a code for creation a PowerPoint presentation using python-pptx library based on given text. Name the pptx file like this:{name}
Please provide output only in code format without anything else. Note that 'SlideShapes' object has no attribute 'subtitle'.
List of topics:
{topics}
Text from book:
{text}
"""

  content = generate_content(prompt_input)
  return content[10:-4]


def generate_topics_for_section(text):
  prompt_input = f"""
You are an assistant with artificial intelligence who gives topics that should be included in this section of the course.
Please provide output only in code format without anything else.
Section:
{text}

Expected output format:
topic1
topic2
...
"""

  content = generate_content(prompt_input)[4:-4]
  return content.split('\n')



def extract_section_topics_from_db(section, collection):
  topics = generate_topics_for_section(section)

  output={}

  for query in topics:
    # Generate embeddings for the query
    query_embedding = embedding_function.call(query)

    # Retrieve relevant documents from ChromaDB
    try:
      results = collection.query(
          query_embeddings=query_embedding,
          n_results=1
      )
    except Exception as e:
      print(f"Error occured in data extraction from db: {e}")
      results=[]


    if results['ids'][0]!=[]:

      # Extract content from the results
      retrieved_docs = results['documents'][0]

      output[query] = retrieved_docs

    else:
       output[query] = ['There is no data on this topic in the book.']

  return output, topics


def topics2code(sections, docs):
  files_py = []
  file_pptx = []
  for i, section in enumerate(sections):

    code=generate_quastion_for_PP_code(section, docs[i], f"Lecture{i}.pptx")

    while 'error generating the response' in code:
      code=generate_quastion_for_PP_code(section, docs[i], f"Lecture{i}.pptx")

    files_py.append(f"Lecture{i}.py")
    file_pptx.append(f"Lecture{i}.pptx")

    with open(f"Lecture{i}.py", "w") as f:
      f.write(code)

  return files_py, file_pptx


def code_execution(files):
  libdir = "/content/"
  for i in files:
    with open(i, 'r') as f:
      code = f.read()
      exec(code)

bot = telebot.TeleBot('8027460660:AAEUmEgEKl2H5KDdI9mIHe93X9Yk5rcWNyQ')

@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    global collection
    collection = setup_database(embedding_function)

    if collection.count()>0:
      bot.send_message(message.chat.id, "Hi, this is a pptx_creator_bot for creating presentations based on the pdf version of the course book and lecture plan.\nYou already have a pdf file in the database.\nTo continue working with the file, send topics for creating presentations, and to replace the file with another one, send a new pdf file with course materials, but the data from the previous file will be deleted.")
    else:
      bot.send_message(message.chat.id, "Hi, this is a pptx_creator_bot for creating presentations based on the pdf version of the course book and lecture plan.\nTo start creating presentations, send a pdf file with the course materials.")


@bot.message_handler(content_types=['document'])
def handle_pdf(message):
    global collection
    collection = setup_database(embedding_function)

    if collection.count()>0:
      client.delete_collection(name="course")
      collection = setup_database(embedding_function)

    try:


        # Download the PDF file
        file_info = bot.get_file(message.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)

        pdf_path = 'book.pdf'
        # Save the PDF file temporarily
        with open(pdf_path, 'wb') as new_file:
            new_file.write(downloaded_file)

        # Extract text from the PDF
        msg = bot.send_message(message.chat.id, "Please wait while the file is being written to the database. It may take some time.")

        extract_text_from_pdf(pdf_path, collection, message, msg)
        os.remove('book.pdf')


        # Wait for the user to send text
        bot.reply_to(message, 'Successfully saved in the database.')
        bot.reply_to(message, "Please provide me the course content by highlighting each lecture in a separate line so that I can include it in pptx.")

    except Exception as e:
        bot.reply_to(message, f"Error: {e}")


@bot.message_handler(content_types=['text'])
def handle_text(message):
  global collection
  collection = setup_database(embedding_function)

  if collection.count()==0:
    bot.reply_to(message, "The database does not contain data about the book, so first send the pdf file, and then enter the topics of the lectures.")
  else:

    try:
        # Get the text from the user
        sections = message.text
        bot.reply_to(message, "Please wait until the bot sends you the pptx files.")
        sections = sections.split('\n')

        topics=[]
        docs = []

        # Create a PPTX file
        for section in sections:
          outputs, queries = extract_section_topics_from_db(section, collection)
          topics.append(queries)
          docs.append(outputs)

        print(topics)

        codes, presents = topics2code(topics, docs)
        code_execution(codes)

        # Send the PPTX file back to the user
        for i in presents:
          with open(i, 'rb') as pptx_file:
              bot.send_document(message.chat.id, pptx_file)

        for i in presents:
          os.remove(i)

        for i in codes:
          os.remove(i)

    except Exception as e:
        bot.reply_to(message, f"Error: {e}")


# Run the bot
bot.infinity_polling()